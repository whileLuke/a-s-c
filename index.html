<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Average Speed Tracker</title>
<style>
:root{
  --bg:#050507; --card:#0d0d10; --muted:#9aa0a6; --accent:#00d0ff; --glass:rgba(255,255,255,0.03);
  --radius:16px; --gauge-size:360px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial}
body{background:linear-gradient(180deg,#040406 0%, #0b0b0f 100%);color:#e9eef2;padding:20px;display:flex;align-items:flex-start;justify-content:center}
.container{width:100%;max-width:920px}
.header{display:flex;align-items:center;gap:12px;margin-bottom:18px}
.logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,#00d0ff,#7b61ff);display:flex;align-items:center;justify-content:center;font-weight:700;color:#041018}
.h1{font-size:20px;margin:0}
.card{background:var(--card);border-radius:var(--radius);padding:18px;margin-bottom:14px;box-shadow:0 6px 20px rgba(0,0,0,0.6);}
.controls{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:10px}
.controls button,input{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:10px;border-radius:12px;color:var(--muted)}
.stats{display:flex;gap:10px;margin-top:12px}
.stat{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:12px;border-radius:12px;text-align:center}
.stat .label{font-size:12px;color:var(--muted)}
.stat .value{font-size:18px;font-weight:700}
.layout{display:grid;grid-template-columns:1fr 320px;gap:18px;margin-top:18px}
.left{display:flex;flex-direction:column;align-items:center}
.gauge-card{width:100%;max-width:var(--gauge-size);background:transparent;padding:18px;border-radius:12px;text-align:center}
#f1Gauge{width:100%;height:auto;display:block}
.gauge-title{font-size:12px;color:var(--muted);letter-spacing:1px;margin-top:6px}
.required-box{margin-top:18px;background:linear-gradient(90deg, rgba(0,0,0,0.2), rgba(255,255,255,0.02));padding:14px;border-radius:12px}
.required-label{font-size:12px;color:var(--muted);letter-spacing:1px}
.required-value{font-size:44px;font-weight:800;margin-top:6px}
.right{display:flex;flex-direction:column;gap:12px}
.card.small{padding:12px}
.zone-name{font-size:13px;color:var(--muted)}
#status{font-size:13px;color:var(--muted);margin-top:8px}
footer{margin-top:12px;color:var(--muted);font-size:12px}
@media(max-width:880px){.layout{grid-template-columns:1fr} .controls{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="logo">F1</div>
    <div>
      <h1 class="h1">F1-style Average Speed Tracker</h1>
      <div style="color:var(--muted);font-size:13px">Average speed in-zone (gauge) • Required speed shown separately</div>
    </div>
  </div>

  <div class="card">
    <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap">
      <div style="flex:1;min-width:220px">
        <input id="zonesUrl" placeholder="Camera zones JSON URL (optional)" />
      </div>
      <div style="display:flex;gap:8px;min-width:260px">
        <button id="loadZones">Load Zones</button>
        <button id="setStart">Set Start (GPS)</button>
        <button id="begin">Start</button>
        <button id="stop">Stop</button>
      </div>
    </div>
    <div class="stats">
      <div class="stat"><div class="label">CURRENT SPEED</div><div id="curSpeed" class="value">-- km/h</div></div>
      <div class="stat"><div class="label">AVERAGE (SO FAR)</div><div id="avgSpeed" class="value">-- km/h</div></div>
      <div class="stat"><div class="label">DISTANCE LEFT</div><div id="distLeft" class="value">-- km</div></div>
    </div>
    <div id="status" style="margin-top:10px">Ready</div>
  </div>

  <div class="layout">
    <div class="left">
      <div class="card gauge-card">
        <canvas id="f1Gauge" width="720" height="420" aria-label="Average speed gauge"></canvas>
        <div class="gauge-title">AVERAGE SPEED SO FAR</div>

```
    <div class="required-box" style="margin-top:12px">
      <div class="required-label">REQUIRED SPEED FOR REST OF JOURNEY</div>
      <div id="reqSpeed" class="required-value">-- km/h</div>
      <div id="zoneName" class="zone-name" style="margin-top:6px">--</div>
    </div>
  </div>
</div>

<div class="right">
  <div class="card small">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div style="font-size:13px;color:var(--muted)">Current Zone</div>
        <div id="curZoneLabel" style="font-weight:700;margin-top:6px">--</div>
      </div>
      <div style="text-align:right">
        <div style="font-size:13px;color:var(--muted)">Zone Limit</div>
        <div id="curLimit" style="font-weight:700;margin-top:6px">-- km/h</div>
      </div>
    </div>
  </div>

  <div class="card small">
    <div style="font-size:13px;color:var(--muted)">Distance Traveled (in-zone)</div>
    <div id="distTrav" style="font-weight:700;margin-top:8px">-- km</div>
  </div>

  <div class="card small">
    <div style="font-size:13px;color:var(--muted)">Notes</div>
    <div style="margin-top:8px;color:var(--muted);font-size:13px">This single-file version uses OSRM to compute road distance (see code for OSRM_BASE). If routing fails it falls back to straight-line distance.</div>
  </div>
</div>
```

  </div>

  <footer>Tip: Host this file on any static host. Want a small map added? Say the word.</footer>
</div>

<script>
/* ===== Utilities ===== */
function toRad(d){return d*Math.PI/180}
function haversine(lat1,lon1,lat2,lon2){const R=6371e3;const dLat=toRad(lat2-lat1);const dLon=toRad(lon2-lon1);const a=Math.sin(dLat/2)**2+Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))}
function setStatus(t){document.getElementById('status').textContent=t}

/* ===== OSRM config ===== */
const OSRM_BASE = 'https://router.project-osrm.org';
const OSRM_ROUTE_THROTTLE_MS = 10000;

/* ===== State ===== */
let speedZones = [];
let currentZone = null;
let zoneStartTime = null;
let zoneDistanceTravelled = 0; // meters
let lastGPS = null;
let watchId = null;
let lastOSRMCall = 0;
let routeCache = {};

/* ===== Example zones ===== */
const exampleZones = [
  { id:'zone-1', name:'M4 Motorway — Zone 1', speedLimit:90, startCam:{lat:-33.8601,lon:151.2040}, endCam:{lat:-33.8405,lon:151.2310} },
  { id:'zone-2', name:'M5 Tunnel — Zone 2', speedLimit:80, startCam:{lat:-33.9402,lon:151.0502}, endCam:{lat:-33.9551,lon:151.0877} }
];

/* ===== Route distance (OSRM) ===== */
function getRouteCacheKey(fromLat,fromLon,toLat,toLon){return `${fromLat.toFixed(5)},${fromLon.toFixed(5)}->${toLat.toFixed(5)},${toLon.toFixed(5)}`}
async function fetchRouteDistance(fromLat,fromLon,toLat,toLon){
  const key = getRouteCacheKey(fromLat,fromLon,toLat,toLon);
  if(routeCache[key] && (Date.now() - routeCache[key].ts) < 60000) return routeCache[key].distance;
  const now = Date.now();
  if(now - lastOSRMCall < OSRM_ROUTE_THROTTLE_MS){ if(routeCache[key]) return routeCache[key].distance; return haversine(fromLat,fromLon,toLat,toLon); }
  lastOSRMCall = now;
  const coords = `${fromLon},${fromLat};${toLon},${toLat}`;
  const url = `${OSRM_BASE}/route/v1/driving/${coords}?overview=false&geometries=polyline&annotations=distance`;
  try{
    const r = await fetch(url);
    if(!r.ok) throw new Error('OSRM error '+r.status);
    const data = await r.json();
    if(data && data.routes && data.routes.length){ const dist = data.routes[0].distance; routeCache[key]={distance:dist,ts:Date.now()}; return dist }
    return haversine(fromLat,fromLon,toLat,toLon);
  }catch(e){ console.warn('OSRM fetch failed',e); if(routeCache[key]) return routeCache[key].distance; return haversine(fromLat,fromLon,toLat,toLon); }
}

/* ===== Load zones ===== */
async function loadZonesFromUrl(url){ try{ const r = await fetch(url); if(!r.ok) throw new Error('Load failed '+r.status); const data = await r.json(); speedZones = data; setStatus(`Loaded ${speedZones.length} zones`); }catch(e){ setStatus('Load failed: '+e.message) } }
function loadExampleZones(){ speedZones = exampleZones; setStatus('Loaded example zones') }

/* ===== Zone detection ===== */
function detectZoneEntry(lat,lon){ for(const z of speedZones){ const d = haversine(lat,lon,z.startCam.lat,z.startCam.lon); if(d < 50) return z } return null }

/* ===== UI actions ===== */
document.getElementById('loadZones').onclick = async ()=>{ const url = document.getElementById('zonesUrl').value.trim(); if(!url){ loadExampleZones(); return } await loadZonesFromUrl(url) }

document.getElementById('setStart').onclick = ()=>{ navigator.geolocation.getCurrentPosition(p=>{ lastGPS = {lat:p.coords.latitude, lon:p.coords.longitude}; setStatus('Start set from GPS') }, e=>setStatus('GPS error: '+e.message), { enableHighAccuracy:true }) }

document.getElementById('begin').onclick = async ()=>{ if(!speedZones.length) loadExampleZones(); setStatus('Starting tracking...'); watchId = navigator.geolocation.watchPosition(updatePosition, e=>setStatus('GPS error: '+e.message), { enableHighAccuracy:true, maximumAge:1000, timeout:10000 }); }

document.getElementById('stop').onclick = ()=>{ if(watchId!==null){ navigator.geolocation.clearWatch(watchId); watchId=null } currentZone=null; zoneStartTime=null; zoneDistanceTravelled=0; lastGPS=null; setStatus('Stopped'); document.getElementById('zoneName').textContent='--'; document.getElementById('curZoneLabel').textContent='--'; document.getElementById('curLimit').textContent='-- km/h'; document.getElementById('avgSpeed').textContent='-- km/h'; document.getElementById('distTrav').textContent='-- km'; document.getElementById('distLeft').textContent='-- km'; document.getElementById('reqSpeed').textContent='-- km/h'; drawF1(0,0,150);
}

/* ===== Main GPS update ===== */
async function updatePosition(pos){
  const lat = pos.coords.latitude; const lon = pos.coords.longitude; const acc = pos.coords.accuracy;
  if(acc > 50){ setStatus('Poor GPS accuracy: '+acc.toFixed(0)+'m'); return }

  // distance segment
  if(lastGPS){ const seg = haversine(lastGPS.lat,lastGPS.lon,lat,lon); if(seg >= 3){ if(currentZone) zoneDistanceTravelled += seg } }
  lastGPS = {lat,lon};

  // current speed
  const speedMs = (pos.coords.speed !== null && pos.coords.speed >= 0) ? pos.coords.speed : 0;
  const curKmh = speedMs * 3.6;
  document.getElementById('curSpeed').textContent = curKmh.toFixed(1) + ' km/h';

  // zone entry
  if(!currentZone){ const zone = detectZoneEntry(lat,lon); if(zone){ currentZone = zone; zoneStartTime = Date.now(); zoneDistanceTravelled = 0; setStatus('Entered zone: '+zone.name); document.getElementById('zoneName').textContent = zone.name; document.getElementById('curZoneLabel').textContent = zone.name; document.getElementById('curLimit').textContent = zone.speedLimit + ' km/h'; } }

  if(currentZone){
    const elapsedHours = Math.max(1e-6, (Date.now() - zoneStartTime)/3600000);
    const avgKmh = (zoneDistanceTravelled/1000) / elapsedHours;
    document.getElementById('avgSpeed').textContent = avgKmh>0? avgKmh.toFixed(1)+' km/h' : '-- km/h';
    document.getElementById('distTrav').textContent = (zoneDistanceTravelled/1000).toFixed(3) + ' km';

    // remaining distance
    let remaining = haversine(lat,lon,currentZone.endCam.lat,currentZone.endCam.lon);
    try{ const routeDist = await fetchRouteDistance(lat,lon,currentZone.endCam.lat,currentZone.endCam.lon); remaining = routeDist }catch(e){ console.warn('Route fetch error',e) }
    document.getElementById('distLeft').textContent = (remaining/1000).toFixed(3) + ' km';

    // required average calculation (for remainder to achieve zone limit)
    const travelledKm = zoneDistanceTravelled/1000;
    const remainingKm = Math.max(0.000001, remaining/1000);
    const totalKm = travelledKm + remainingKm;
    const limit = currentZone.speedLimit;
    const numerator = (limit * totalKm) - (avgKmh * travelledKm);
    let requiredAvg = 0;
    if(numerator > 0){ requiredAvg = numerator / remainingKm; requiredAvg = Math.min(requiredAvg, 300); }
    document.getElementById('reqSpeed').textContent = requiredAvg > 0 ? requiredAvg.toFixed(1) + ' km/h' : '-- km/h';

    // update gauge with avg (gauge shows average only)
    drawF1(curKmh, avgKmh, limit);

    // zone finish
    if(remaining < 15){ const finalElapsedHours = Math.max(1e-6,(Date.now()-zoneStartTime)/3600000); const finalAvg = (zoneDistanceTravelled/1000)/finalElapsedHours; alert(`Zone finished: ${currentZone.name}\nAverage speed: ${finalAvg.toFixed(1)} km/h\nLimit: ${currentZone.speedLimit} km/h`); currentZone=null; zoneStartTime=null; zoneDistanceTravelled=0; document.getElementById('zoneName').textContent='--'; document.getElementById('curZoneLabel').textContent='--'; document.getElementById('curLimit').textContent='-- km/h'; document.getElementById('avgSpeed').textContent='-- km/h'; document.getElementById('distTrav').textContent='-- km'; document.getElementById('distLeft').textContent='-- km'; document.getElementById('reqSpeed').textContent='-- km/h'; drawF1(0,150); }
  }
}

/* ===== On load ===== */
loadExampleZones();

/* ===== F1-style gauge rendering ===== */
const f1 = document.getElementById('f1Gauge');
const ctx = f1.getContext('2d');
function drawF1(currentSpeed, avgSpeed, limit){
  // Responsive canvas sizing and DPI
  const dpr = window.devicePixelRatio || 1;
  const W = f1.clientWidth;
  const H = Math.max(120, Math.round(W * 0.6));
  f1.width = Math.round(W * dpr);
  f1.height = Math.round(H * dpr);
  f1.style.height = H + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,W,H);

  // layout: keep circle fully inside canvas (avoid clipping)
  const cx = W/2;
  const cy = H * 0.95; // push center slightly above bottom
  const r = Math.min(W*0.45, H*0.95);

  // determine color based on CURRENT speed vs limit
  const safeLimit = Math.max(1, limit || 1);
  const pct = Math.min(1, Math.max(0, (currentSpeed / safeLimit)));
  let color = '#00ff66';
  if(pct > 0.9) color = '#ff3b3b';
  else if(pct > 0.7) color = '#ffe066';

  // neon glow arc
  ctx.lineWidth = Math.max(12, Math.round(H * 0.08));
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.shadowBlur = 30; ctx.shadowColor = color;
  ctx.strokeStyle = color;
  ctx.arc(cx, cy, r, Math.PI, 2*Math.PI, false);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // subtle outline for contrast
  ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.arc(cx,cy,r,Math.PI,2*Math.PI); ctx.stroke();

  // needle based on CURRENT speed
  const angle = Math.PI + (Math.PI * pct);
  const nx = cx + Math.cos(angle) * (r * 0.88);
  const ny = cy + Math.sin(angle) * (r * 0.88);

  // needle shadow/hub
  ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.arc(cx,cy,10,0,2*Math.PI); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.lineWidth = Math.max(3, Math.round(H*0.02)); ctx.strokeStyle = color; ctx.stroke();
  ctx.beginPath(); ctx.fillStyle = '#ffffff'; ctx.arc(cx,cy,5,0,2*Math.PI); ctx.fill();

  // Average number in center (gauge shows average)
  const avgDisplay = (isFinite(avgSpeed) && avgSpeed>0) ? Math.round(avgSpeed) : 0;
  ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.font = `700 ${Math.round(H*0.22)}px Inter, system-ui, sans-serif`;
  ctx.fillText(`${avgDisplay}`, cx, H*0.55);

  // small "km/h"
  ctx.font = `14px Inter, system-ui, sans-serif`; ctx.fillStyle = 'rgba(255,255,255,0.75)'; ctx.fillText('km/h', cx, H*0.73);

  // small labels
  ctx.font = '12px Inter, system-ui, sans-serif'; ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillText(`Limit ${limit} km/h`, cx, H*0.95);
}

// initial draw
window.addEventListener('load', ()=> drawF1(0,150) );
window.addEventListener('resize', ()=>{ // redraw to keep proportions
  // read current speeds from UI
  const curRaw = document.getElementById('curSpeed').textContent.trim().split(' ')[0]; const cur = parseFloat(curRaw);
  const avgRaw = document.getElementById('avgSpeed').textContent.trim().split(' ')[0]; const avg = parseFloat(avgRaw);
  const limit = (currentZone ? currentZone.speedLimit : 150);
  drawF1(isNaN(cur)?0:cur, isNaN(avg)?0:avg, limit);
});;

</script>

</body>
</html>
